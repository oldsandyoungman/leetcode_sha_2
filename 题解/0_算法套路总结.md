把 `labuladong` 的算法快刷完第二遍了，记录下有迹可循的套路

[TOC]

#### 回溯法



##### 思路

1.核心3个要素：

- base0，即终止条件
- 状态，即已走过的路径记录
- 选择，即当前有哪些选项可选



2.另外回溯法当选择不同主体时，会有不同的时间复杂度，例如数选桶桶选数问题：

> [东哥链接](https://labuladong.gitee.io/algo/4/29/111/)
>
> [leetcode链接](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/)



3.如果是返回所有结果，函数外定义一个res来记录，函数本身返回void

如果只要返回boolean，那么不需要额外的res来记录，函数本身返回boolean即可







##### 技巧

1. 数组遍历的题目，可以将dfs函数的参数设置为start，因此每次调用函数的状态，就是说start到最后（选择是选或不选）

2. 永远别忘了，每一步回溯都要撤回当前的操作



#### 备忘录

##### 位图备忘录

如果数组长度小于等于16，可以用int来记录状态：

```java
int state;
HashMap<Integer, Boolean> memo;
```

1. 更新第 i 位状态

   ```java
   state = state|(1<<i);
   // 或者
   state |= 1<<i;
   ```

2. 撤销更新第 i 位状态

   ```java
   state = state^(1<<i);
   // 或者
   state ^= 1<<i;
   ```

3. 判断第 i 位的数是否为target

   ```java
   if((state>>i&1)==target){
       
   }
   ```

   

#### 快排，快选

##### 随机打乱

千万别忘了快排前随机打乱数组，不然效率会下降不少

```java
public void shuffle(int[] nums){
    int n = nums.length;
    Random r = new Random();
    for(int i=0; i<n; i++){
        int index = i + r.nextInt(n-i);
        swap(nums, i, index);
    }
}
```

